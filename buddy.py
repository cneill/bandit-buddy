#!/usr/bin/env python

"""
================================================================================
                               BANDIT BUDDY
================================================================================
Get information about results generated by OpenStack Bandit. INFILE should be
a JSON-formatted Bandit results file (generated by bandit -f json). If OUTFILE
is a directory, we will create a file called "results.html"
================================================================================

Usage:
    buddy.py INFILE [CONFIGFILE] [OUTFILE]
    buddy.py --help

Options:
    INFILE        Specify the file to read bandit results from (in JSON format)
    CONFIGFILE    Specify the file to load project settings from (in JSON format) [default: ./config.json]
    OUTFILE       Specify the file for results to be written to [default: ./results.html]
    --help        Print help message
"""

import json
# import re
import os

from docopt import docopt
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
from jinja2 import Template
from six.moves.urllib.parse import quote_plus


CWD = os.path.realpath(os.path.curdir)
INSTALL_DIR = os.path.realpath(os.path.dirname(__file__))


def parse_config(path):
    ret = {}

    if not os.path.isfile(path):
        raise Exception('File not found')

    with open(path, 'r') as f:
        contents = f.read()
        j = json.loads(contents)
        ret['project_name'] = j.get('project_name', 'UNNAMED PROJECT')
        template = j.get('template', 'default')
        style = j.get('style', 'default')
        ret['repository'] = j.get('repository', None)
        ret['branch'] = j.get('branch', 'master')

    ret['template'] = os.path.join(
        CWD, 'resources/templates/{0}.html'.format(template)
    )
    ret['result_template'] = os.path.join(
        CWD, 'resources/templates/{0}_result.html'.format(template)
    )
    ret['stats_template'] = os.path.join(
        CWD, 'resources/templates/{0}_stats.html'.format(template)
    )
    ret['style'] = os.path.join(
        CWD, 'resources/styles/{0}.css'.format(style)
    )

    return ret


def read_results_file(path):
    if not os.path.isfile(path):
        raise Exception('File not found')

    with open(path, 'r') as f:
        contents = f.read()
        return contents


def parse_results(contents, conf):
    ret = {
        'stats': '',
        'results': ''
    }
    j = json.loads(contents)
    results = j['results']
    stats = j['stats']

    if not os.path.isfile(conf['result_template']):
        raise Exception('Could not load specified result template')
    else:
        with open(conf['result_template'], 'r') as f:
            result_template_contents = f.read()

    if not os.path.isfile(conf['stats_template']):
        raise Exception('Could not load specified stats template')
    else:
        with open(conf['stats_template'], 'r') as f:
            stats_template_contents = f.read()

    findings = {
        'findings': 0,
        'high_findings': 0,
        'med_findings': 0,
        'low_findings': 0,
        'unknown_findings': 0
    }

    for stat in stats:
        findings['high_findings'] += stat['issue totals']['HIGH']
        findings['med_findings'] += stat['issue totals']['MEDIUM']
        findings['low_findings'] += stat['issue totals']['LOW']
        findings['unknown_findings'] += stat['issue totals']['UNDEFINED']

    findings['findings'] = (
        findings['high_findings'] + findings['med_findings'] +
        findings['low_findings'] + findings['unknown_findings']
    )

    stats_template = Template(stats_template_contents)
    ret['stats'] += stats_template.render(findings)

    for result in results:
        result_template = Template(result_template_contents)
        issue = result['issue_text']
        severity = result['issue_severity']
        confidence = result['issue_confidence']
        if conf['repository'] and conf['branch']:
            file_path = quote_plus(result['filename']).replace("%2F", "/")
            path = '{repo}/blob/{branch}/{path}'.format(
                repo=conf['repository'], branch=conf['branch'],
                path=file_path)
            if result['line_number']:
                path += '#L{0}'.format(result['line_number'])
        else:
            path = result['filename']
        code = highlight(result['code'], PythonLexer(), HtmlFormatter())
        ret['results'] += result_template.render(
            issue=issue, severity=severity, confidence=confidence, path=path,
            code=code
        )

    return ret


def write_parsed_to_file(path, stats, results, conf):
    if os.path.isfile(path):
        decision = raw_input(
            'Delete existing file? ({0}) [Y/n]: '.format(path)
        ).strip()
        if decision.lower() == 'y':
            os.remove(path)
        else:
            raise Exception('Could not write to specified output file')

    if os.path.isdir(path):
        path = os.path.join(path, 'results.txt')

    if not os.path.isfile(conf['template']):
        raise Exception('Could not load specified template')
    else:
        with open(conf['template'], 'r') as f:
            template_contents = f.read()

    if not os.path.isfile(conf['style']):
        raise Exception('Could not load specified style')
    else:
        with open(conf['style'], 'r') as f:
            style_contents = f.read()

    template = Template(template_contents)
    html = template.render(
        style_contents=style_contents, stats=stats, results=results,
        project_name=conf['project_name']
    )

    with open(path, 'w') as f:
        f.write(html)


def main(args):
    if args['OUTFILE'] is None:
        outfile = os.path.join(CWD, 'results.html')
    else:
        outfile = args['OUTFILE'].strip()

    if args['CONFIGFILE'] is None:
        config_file = os.path.join(CWD, 'config.json')
    else:
        config_file = args['CONFIGFILE'].strip()

    conf = parse_config(config_file)
    file_contents = read_results_file(args['INFILE'])
    parsed = parse_results(file_contents, conf)
    write_parsed_to_file(outfile, parsed['stats'], parsed['results'], conf)


if __name__ == '__main__':
    args = docopt(__doc__, version='0.0')
    main(args)
